#include "Grammar.h"

using namespace LexemeResources;
using namespace std;


//this is only used to move ahead to the next token
bool Grammar::match(){
	return _currentTokens.moveAhead();
}


void Grammar::error(string expectedTokenNames)
{
	//found
	Token next;
	_currentTokens.nextToken(next);

	string found(LexemeNames[(int)next.getType()]);
	int line = next.getLineNumber();
	int column = next.getColumnNumber();

	char buffer[200] = { 0 };
	sprintf(buffer, "ERROR - Expected %s found %s, at line %d and column %d!!", expectedTokenNames.c_str(), found.c_str(), line, column);

	_errString = string(buffer);
}


LexemeType Grammar::nextTokenType() const
{
	return _currentTokens.nextTokenType();
}

bool Grammar::factor()
{

	//switch (_lookAheadToken.getLexeme().getType())
	//{
	//	case Lexeme::
	//}

	return false;
}

bool Grammar::forStatement()
{

	return false;
}

bool Grammar::multiplyingOperator()
{

	return false;
}

bool Grammar::actualParameter()
{

	return false;
}

bool Grammar::actualParameterTail()
{

	return false;
}

bool Grammar::addingOperator()
{

	return false;
}

bool Grammar::assignmentStatement()
{

	return false;
}

bool Grammar::block()
{

	return false;
}

bool Grammar::booleanExpression()
{

	return false;
}

bool Grammar::compoundStatement()
{

	return false;
}

bool Grammar::controlVariable()
{

	return false;
}

bool Grammar::emptyStatement()
{

	return false;
}

bool Grammar::expression()
{

	return false;
}

bool Grammar::factorTail()
{

	return false;
}

bool Grammar::finalValue()
{

	return false;
}

bool Grammar::formalParameterSection()
{

	return false;
}

bool Grammar::formalParameterSectionTail()
{

	return false;
}

bool Grammar::functionDeclaration()
{

	return false;
}

bool Grammar::functionHeading()
{

	return false;
}

bool Grammar::functionIdentifier()
{

	return false;
}

bool Grammar::identifierList()
{

	return false;
}

bool Grammar::identifierTail()
{

	return false;
}

bool Grammar::ifStatement()
{

	return false;
}

bool Grammar::initialValue()
{

	return false;
}

bool Grammar::optionalActualParameterList()
{

	return false;
}

bool Grammar::optionalElsePart()
{

	return false;
}

bool Grammar::optionalFormalParameterList()
{

	return false;
}

bool Grammar::optionalRelationalPart()
{

	return false;
}

bool Grammar::optionalSign()
{

	return false;
}

bool Grammar::ordinalExpression()
{

	return false;
}

bool Grammar::procedureAndFunctionDeclarationPart()
{

	return false;
}

bool Grammar::procedureDeclaration()
{

	return false;
}

bool Grammar::procedureHeading()
{

	return false;
}

bool Grammar::procedureIdentifier()
{

	return false;
}

bool Grammar::procedureStatement()
{

	return false;
}

bool Grammar::program()
{
	if (!programHeading()){
		return false;
	}

//check if the next if next is ;

	//ce

	return false;
}

bool Grammar::programHeading()
{

	return false;
}

bool Grammar::programIdentifier()
{

	return false;
}

bool Grammar::readParameter()
{

	return false;
}

bool Grammar::readParameterTail()
{

	return false;
}

bool Grammar::readStatement()
{

	return false;
}

bool Grammar::relationalOperator()
{

	return false;
}

bool Grammar::repeatStatement()
{

	return false;
}

/*  Rule 82
	Parses strings in the language generated by 
	<SimpleExpression> -> [ Sign ] <Term> <TermTail> */
bool Grammar::simpleExpression()
{
	switch (_lookAheadToken.getLexeme().getType()){
	case LexemeType::MP_PLUS:
		match(LexemeType::MP_PLUS);
		term();
		return termTail();
		break;
	case LexemeType::MP_MINUS:
		match(LexemeType::MP_MINUS);
		term();
		return termTail();
		break;
	default:
		term();
		return termTail();
	}

	/*  Possible alternate implementation?  Need to change call to error
	if (match(LexemeType::MP_PLUS));
	else if (match(LexemeType::MP_MINUS));
	term();
	termTail();
	}
	
	*/
}

bool Grammar::statement()
{

	return false;
}

bool Grammar::statementPart()
{

	return false;
}

bool Grammar::statementSequence()
{

	return false;
}

bool Grammar::statementTail()
{

	return false;
}

bool Grammar::stepValue()
{

	return false;
}

bool Grammar::systemGoal()
{

	return false;
}

bool Grammar::term()
{

	return false;
}

bool Grammar::termTail()
{

	return false;
}

bool Grammar::type()
{

	switch (nextTokenType())
	{
	case MP_INTEGER:
	case MP_BOOLEAN:
	case MP_FLOAT:
	case MP_STRING:
		//all of the above cases fall through to accept
		return match();

	default:
		//Everythng else fails
		error("Type");
	}

	return false;
}

bool Grammar::valueParameterSection()
{

	return false;
}

bool Grammar::variableDeclaration()
{

	return false;
}

bool Grammar::variableDeclarationPart()
{

	return false;
}

bool Grammar::variableDeclarationTail()
{

	return false;
}

bool Grammar::variableIdentifier()
{

	return false;
}

bool Grammar::variableParameterSection()
{

	return false;
}

bool Grammar::whileStatement()
{

	return false;
}

bool Grammar::writeParameter()
{

	return false;
}

bool Grammar::writeParameterTail()
{

	return false;
}

bool Grammar::writeStatement()
{

	return false;
}

