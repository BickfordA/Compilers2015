<!DOCTYPE html> 
<html><!-- InstanceBegin template="/Templates/page.dwt" codeOutsideHTMLIsLocked="false" -->

<!-- Mirrored from hypertextbookshop.com/compilers2015/Contents/02_Portfolios/05_Team_5/4_Technical_Writing/Technical_Writing.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 27 Apr 2015 02:54:08 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<link rel="stylesheet" href="../../../../Stylesheets/prettify.css" />
<link rel="stylesheet" href="../../../../Stylesheets/pageStylesheet.css" />
<link rel="stylesheet" href="../../../../Stylesheets/navigationStylesheet.css" />
<link rel="stylesheet" href="../../../../Stylesheets/allTextStyles.css" />
<link rel="stylesheet" href="../../../../Stylesheets/colors-blue.css" />

<script type="text/javascript" src="../../../../Scripts/google-code-prettify/run_prettify.js"></script>
<script type="text/javascript" src="../../../../Scripts/recomputeAttributes.js"></script>


<!-- InstanceBeginEditable name="doctitle" -->
<title>Technical Writing</title>
<!-- InstanceEndEditable -->

<script language="JavaScript" type="text/javascript">
<!-- Copyright 2005, Sandeep Gangadharan -->
<!-- For more free scripts go to http://www.sivamdesign.com/scripts/ -->
<!-- Borrowed from http://www.ehow.com/how_5772308_expand-collapse-text.html -->
<!--
if (document.getElementById) {
document.writeln('<style type="text/css"><!--')
document.writeln('.texter {display:none} @media print {.texter {display:block;}}')
document.writeln('//--></style>') }

function openClose(theID) {
if (document.getElementById(theID).style.display == "block") { document.getElementById(theID).style.display = "none" }
else { document.getElementById(theID).style.display = "block" } }
// -->
</script>

</head>

<body id="body-style">

<!-- 
<div id="browser-window-veil">
</div>
-->

<div id="page-container">

<header id="header">
<div id="track-icon1">
  <img src="../../../../Media/StyleImages/bobcat-small.png" alt="bobcat icon" width="75" height="48"></div>
<div id="track-icon2">
</div>
<div id="track-icon3">
</div>
  <div id="headMatter">
    <span id="headTitle1">
      <!-- InstanceBeginEditable name="Header" -->
        Technical Writing
	  <!-- InstanceEndEditable --> 
    </span>
    <span id="headTitle2">
    </span>
  </div>
</header>

<nav id="navigate">
<ul id="nav" >
  <li><a href="../../../../default.html">Cover</a>
  </li>
  <li><a href="#">Contents</a>
    <ul class="dropdownMenu">
      <li><a href="../../../01_Introduction/1_Project_Overview/Overview_1.html">Introduction</a></li>
      <li><a href="../0_Introduction/Cover.html">Portfolios</a></li>
    </ul>
  </li>
  <li><a href="#">Portfolios</a>
    <ul class="dropdownMenu">
      <li><a href="../0_Introduction/Cover.html">Team 5</a></li>
    </ul>
  </li>
  <li><a href="#">Team 5</a>
    <ul class="dropdownMenu">
      <li><a href="../0_Introduction/Cover.html">Introduction</a></li>
      <li><a href="../1_Program/1_Scanner_Code.html">Program</a></li>
      <li><a href="../2_Teamwork/teamwork.html">Teamwork</a></li>
      <li><a href="../3_Design_Pattern/design_pattern.html">Design Pattern</a></li>
      <li><a href="Technical_Writing.html">Technical Writing</a></li>
      <li><a href="../5_UML/1_Symbol_Table.html">UML</a></li>
      <li><a href="../6_Design_Tradeoffs/Deesign_Tradeoffs.html">Design Tradeoffs</a></li>
      <li><a href="../7_Life_Cycle/Life_Cycle.html">Life Cycle</a></li>
    </ul>
  </li>
  <li><a href="#">Technical Writing</a>
    <ul class="dropdownMenu">
      <li><a href="Technical_Writing.html">Technical Writing </a></li>
    </ul>
  </li>
  <li><a href="../../../../help.html" target="_blank">Help</a>
  </li>
</ul>
</nav>


<aside id="aside-left">
<div id="asideLeftTitle">
Compilers 2015
</div>

</aside>

<aside id="aside-right">
</aside>

<footer id="footer">
  <div id="footMatter">
    <span id="previousPageLink">
    </span>
    <span id="currentPageNumber">
      Page 1 of 1
    </span>
    <span id="nextPageLink">
    </span>
  </div>
</footer>

<article id="mainContent">
<!-- InstanceBeginEditable name="Main" -->
<h1>Technical Writing</h1>

<div onClick="openClose('a1')" style="cursor:hand; cursor:pointer"><b><font color = "blue">Aidan Bickford</font></b></div>
<div id="a1" class="texter">
Place Paper Here<br /><br />
</div>

<div onClick="openClose('a2')" style="cursor:hand; cursor:pointer"><b><font color = "blue">Agata Gruza</font></b></div>
<div id="a2" class="texter">
Place Paper Here<br /><br />
</div>

<div onClick="openClose('a3')" style="cursor:hand; cursor:pointer"><b><font color = "blue">Joseph DeBruycker</font></b></div>
<div id="a3" class="texter">
Place Paper Here<br /><br />
</div>

<div onClick="openClose('a4')" style="cursor:hand; cursor:pointer"><b><font color = "blue">Travis Wentz</font></b></div>
<div id="a4" class="texter">
<blockquote>	In this paper we will assume that the reader has a knowledge of LL(1) tables and the C++ language, as well as a working knowledge of context-free grammar. We will further discuss context-free grammar and how it works together with an LL(1) table and C++ in the construction of our parser. Context-free grammar played a crucial role in the design and construction of our parser. The method of parsing that we used, which was based off of an LL(1) table, was entirely built on context-free grammar. All the rules are built in the context-free grammar style. That is, each non-terminal can go to one or more terminals or non-terminals. In our Grammar.cpp the function for parsing &ltaddingOperator&gt is a good example of this. AddingOperator is a non-terminal, with regards to our particular grammar, this means that &ltaddingOperator&gt is not a token. Any terminal is a token, whereas any non-terminal is not a token but a rule. So, the non-terminal &ltaddingOperator&gt leads to a variety of terminals (whereas some rules also lead to other non-terminals and/or terminals) through certain rules which are traced in the LL(1) table. A more traditional way of writing a rule in a context-free grammar might be as follows: &ltaddingOperator&gt -> Plus; &ltaddingOperator&gt -> Minus; &ltaddingOperator&gt -> Or; or &ltaddingOperator&gt -> Plus | Minus | Or. In our project, we simply translated this to C++ code using switch statements:
<br>bool Grammar:: addingOperator(SemanticRecord& record){<br>
switch (nextTokenType()) {<br>
		case MP_PLUS:<br>
			…<br>
			return true;<br>
		case MP_MINUS:<br>
			…<br>
			return true;<br>
		case MP_OR:<br>
			…<br>
			return true;<br>
default:<br>
			error(TypeList() << MP_PLUS << MP_MINUS << MP_OR );<br>
	}<br>
	What is actually happening here is that the current function we are looking at is the function for the non-terminal &ltaddingOperator&gt. This being an implementation of LL(1), we look ahead one spot and hope to see one of the three terminals, or tokens, this rule can accept. Based on the grammar, &ltaddingOperator&gt is allowed to go to any one of these three tokens and nothing else. Therefor, if what is read next is not one of these three tokens, an error is thrown telling the user what was expected. If however, what is read next is one of the three acceptable tokens a variety of things happens. The token is accepted by the switch statement and then all that needs to happen for that accept state (such as logging the rule, matching the token, writing the machine code, etc.) is told to happen and the parser moves on to the next spot to repeat the process all over again. This process ends when the eof token is reached.
	There are occasionally conflicts in the grammar, meaning that a non-terminal can go to a single terminal by more than one rule (eg. &ltfactor&gt -> &ltidentifier&gt by rule 106 or 116). This suggests that the grammar was not designed as an LL(1) grammar, meaning that the intention was, perhaps, to look ahead more than one spot. As we were using LL(1) (looking ahead only one spot) and that was not to change, we had to choose how to deal with these conflicts. What we ended up doing was limiting the grammar by simply choosing one of the rules and only letting the grammar take that path; in the case of &ltfactor&gt, we modified it so that it was only allowed to get to &ltidentifier&gt via rule 106 only and was not allowed to go to &ltidentifier&gt via rule 116.
	Context-free grammar, therefor, was crucial in building our compiler and was the rock upon which our parser was built. Using the LL(1) method had a few tradeoffs, but overall worked very well for parsing this context-free grammar.
</blockquote><br /><br />
</div>

<div onClick="openClose('a5')" style="cursor:hand; cursor:pointer"><b><font color = "blue">Vasudev Ravula</font></b></div>
<div id="a5" class="texter">
Place Paper Here<br /><br />
</div>

<div onClick="openClose('a6')" style="cursor:hand; cursor:pointer"><b><font color = "blue">Menghao Han</font></b></div>
<div id="a6" class="texter">
Place Paper Here<br /><br />
</div>

</article>
</div>
</body>
<!-- InstanceEnd -->
<!-- Mirrored from hypertextbookshop.com/compilers2015/Contents/02_Portfolios/00_Team_0/4_Technical_Writing/Technical_Writing.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 27 Apr 2015 02:54:08 GMT -->
</html>
